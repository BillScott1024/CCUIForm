{"version":3,"sources":["Stack.ts"],"names":[],"mappings":";;;;AAAA;;;;;;;;;GASG;AAWH;IAGI,cAAY,KAAQ,EAAE,IAAoB;QAApB,qBAAA,EAAA,WAAoB;QACtC,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC;QACpB,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC;IACtB,CAAC;IACD,sBAAI,uBAAK;aAGT;YACI,OAAO,IAAI,CAAC,MAAM,CAAC;QACvB,CAAC;aALD,UAAU,KAAQ;YACd,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC;QACxB,CAAC;;;OAAA;IAID,sBAAI,sBAAI;aAGR;YACI,OAAO,IAAI,CAAC,KAAK,CAAC;QACtB,CAAC;aALD,UAAS,IAAa;YAClB,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC;QACtB,CAAC;;;OAAA;IAIL,WAAC;AAAD,CAnBA,AAmBC,IAAA;AAED;IAGI;QADQ,UAAK,GAAW,CAAC,CAAC;QAEtB,IAAI,CAAC,OAAO,GAAG,IAAI,IAAI,CAAI,IAAI,CAAC,CAAC;IACrC,CAAC;IACD,mBAAG,GAAH;QACI,IAAI,IAAI,CAAC,KAAK,KAAK,CAAC,EAAE;YAClB,OAAO,IAAI,CAAC;SACf;QACD,OAAO,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC;IACnC,CAAC;IAED;;;;;OAKG;IACH,oBAAI,GAAJ,UAAK,IAAO;QACR,IAAI,OAAO,GAAG,IAAI,IAAI,CAAI,IAAI,CAAC,CAAC;QAChC,OAAO,CAAC,IAAI,GAAG,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC;QACjC,IAAI,CAAC,OAAO,CAAC,IAAI,GAAG,OAAO,CAAC;QAC5B,IAAI,CAAC,KAAK,EAAE,CAAC;IACjB,CAAC;IAED;;;;OAIG;IACH,mBAAG,GAAH;QACI,IAAI,IAAI,CAAC,KAAK,KAAK,CAAC,EAAE;YAClB,OAAO,IAAI,CAAC;SACf;QACD,IAAI,IAAI,GAAG,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC;QAC7B,IAAI,CAAC,OAAO,CAAC,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;QAC9B,IAAI,CAAC,KAAK,EAAE,CAAC;QACb,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,CAAA,MAAM;QACvB,OAAO,IAAI,CAAC,KAAK,CAAC;IACtB,CAAC;IAED,qBAAK,GAAL;QACI,OAAO,IAAI,CAAC,KAAK,KAAK,CAAC,CAAC;IAC5B,CAAC;IAED,oBAAI,GAAJ;QACI,OAAO,IAAI,CAAC,KAAK,CAAC;IACtB,CAAC;IACL,YAAC;AAAD,CAjDA,AAiDC,IAAA","file":"","sourceRoot":"../../../../../assets/Scripte/Utils","sourcesContent":["/**\n *    Title: UI框架项目\n *           主题: 栈\n *           功能: 后进先去\n *      \n *        \n *    Date: 2018.6.11\n *    Version: 0.1版本\n *    by : wxy\n */\n\n\ninterface IStack<T> {\n    top(): T;//获取栈顶元素\n    push(item: T);//压栈\n    pop(): T;//出栈\n    empty(): boolean;//是否空栈\n    size(): number;//栈大小\n}\n\nclass Item<T> {\n    private _value: T;\n    private _next: Item<T>;\n    constructor(value: T, next: Item<T> = null) {\n        this._value = value;\n        this._next = next;\n    }\n    set value(value: T) {\n        this._value = value;\n    }\n    get value(): T {\n        return this._value;\n    }\n    set next(next: Item<T>) {\n        this._next = next;\n    }\n    get next(): Item<T> {\n        return this._next;\n    }\n}\n\nclass Stack<T> implements IStack<T> {\n    private _header: Item<T>;\n    private _size: number = 0;\n    constructor() {\n        this._header = new Item<T>(null);\n    }\n    top(): T {\n        if (this._size === 0) {\n            return null;\n        }\n        return this._header.next.value;\n    }\n\n    /**\n     * 入栈\n     * @param item 添加的元素\n     * 将header的下一个元素的引用赋值给新元素的next\n     * 再将新元素赋值给header的next\n     */\n    push(item: T) {\n        let newItem = new Item<T>(item);\n        newItem.next = this._header.next;\n        this._header.next = newItem;\n        this._size++;\n    }\n\n    /**\n     * 出栈\n     * 将header之后的第一个元素移除\n     * 同时修改header的next到下一个元素\n     */\n    pop(): T {\n        if (this._size === 0) {\n            return null;\n        }\n        let item = this._header.next;\n        this._header.next = item.next;\n        this._size--;\n        item.next = null;//清除引用\n        return item.value;\n    }\n\n    empty(): boolean {\n        return this._size === 0;\n    }\n\n    size(): number {\n        return this._size;\n    }\n}"]}